\documentclass[11pt, a4paper]{article}
\usepackage[english, science, small]{ku-frontpage}
\usepackage[utf8]{inputenc}
\usepackage[cache=false]{minted}

\usepackage{listings}
\lstdefinestyle{Bash}
{language=bash,
	keywordstyle=\color{blue},
	basicstyle=\ttfamily,
	morekeywords={peter@kbpet},
	alsoletter={:~\$},
	morekeywords=[2]{peter@kbpet:},
	keywordstyle=[2]{\color{red}},
	literate={\$}{{\textcolor{red}{\$}}}1 
	{:}{{\textcolor{red}{:}}}1
	{~}{{\textcolor{red}{\textasciitilde}}}1,
}

\setlength\arraycolsep{2 pt}
\setcounter{tocdepth}{2}
\setcounter{secnumdepth}{0}

\author{Per Steffen Czolbe, Konrad Gnoinski}
\title{Advanced Programming}
\subtitle{Assignment 4: Kaboose} % No subtitle
\date{Handed in: \today}

\begin{document}
\maketitle

\tableofcontents


\section{Description of the Assignment}
The goal of the assignment is to implement the backend part of a Kahoot!-like service called Kaboose!. That is, a Kaboose! server is a central server where you create new quiz rooms. When you have created a quiz you need to add some questions to it before you can play the quiz. When your quiz is ready, you can open the quiz room for players. The players need to join the quiz before they can make guesses. To play a quiz there needs to be exactly one conductor and a number of players.

The play of a quiz is that the conductor makes the questions active in turn, and then the playersâ€™ guesses are collected. After each question, each player is awarded points based on the correctness of the answer, and the swiftness of reply. [Larsen, 2017]

\pagebreak
\section{Solution}
This section gives a brief overview about the structure of the solution and how to execute the code.

\subsection{Tools}
Kahoot is implemented in Erlang, a language that handles the concurrency of different quiz rooms very well. A modified version of the basic server library supplied in the lecture is used for communication, and EUnit is used for unit tests. Emake is used to build the project.

\subsection{Files}
The code is organised in multiple files and directories:
\begin{itemize}
	\item \texttt{src/}: the project directory. 
	\begin{itemize}
		\item \texttt{kaboose.erl}: the kaboose module.
		\item \texttt{room.erl}: a module containing the implementation of a game room.
		\item \texttt{activeRoom.erl}: a module containing the implementation of an active game room.
		\item \texttt{test/}: a directory with test cases.
		\begin{itemize}
			\item \texttt{kaboose\_tests.erl}: the tests for the kaboose module.
		\end{itemize}
		\item \texttt{Emakefile}: a file congaing Emake configuration.
		\item \texttt{ebin/}: a directory containing the binary files generated by Emake.
	\end{itemize}
\end{itemize}

\subsection{Program Execution}
To compile and load the kaboose module navigate to the project directory and run:

\begin{minted}{erlang}
$ erl
1> make:all([load]).
\end{minted}

This triggers Emake to compile and load all files in the project. Note that a \texttt{src/ebin/} directory must exist.

Now functions of the kaboose module can be called from the eshell.


\subsection{Running Tests}
First, follow the steps in the previous section to compile and load all the project files. Afterwards, all test cases can be run in verbose mode with a single command:

\begin{minted}{erlang}
2> eunit:test(kaboose, [verbose]).
\end{minted}




\pagebreak
\section{Implementation}
This section contains a description of the implementation. First, our assumptions regarding the assignment are stated. Next, concepts of how to tackle the harder parts of the implementation are discussed.

\subsection{Assumptions} \label{perfect-world}
Erlang is a dynamically typed language. This allows for a wide range of possible errors as a result of arbitrarily structured inputs. Instead of performing a sanity-check on each input, we apply the "perfect-world" assumption: a user always supplies inputs in the expected format. 


\subsection{Keeping Things Organized}
To structure the code, we first identify three different layers of the kaboose application:
\begin{itemize}
	\item kaboose, the main server managing the creation of game rooms.
	\item room, a type of process that manages adding questions to a room and creating active rooms.
	\item activeRoom, a type of process that resembles an active game.
\end{itemize}
Each of these three layers represents a different type of process. To structure the source code, each of them is implemented in a separate module and file. To still conform with the API as defined by the assignment, the kaboose module offers functions for the other modules as well, but merely calls the implementation of those functions in the other modules.


\subsection{Processes and Communication}
To facilitate the communication and basic functionality of processes, we use a modified version of the \texttt{basic\_server} module presented in the lecture. To suit our needs, we performed two modifications to it:
\begin{itemize}
	\item The initial implementation registered processes as names. But as registered names have to be unique, a trivial implementation would only allow one process of each type to run at a time. To circumvent this restriction without adding too much complexity, we decided to not register processes and instead just use the pid to refer to processes.
	\item The basic\_server was only offering a request-reply communication pattern. For this solution, a asynchronous communication pattern was added. 
	\item Kill function has been added so a process can terminate itself. 
\end{itemize}

With two different communication pattern available, we choose which pattern to use for each function based on if a result needs to be communicated. This used patterns are shown in table \ref{tab1}.

\begin{table}[h!]
	\centering
	\caption{Communication patterns used in API functions}
	\label{tab1}
	\begin{tabular}{l|l}
		function                                                          & communication pattern \\ \hline
		get\_a\_room                                                      & request-reply         \\
		add\_question                                                     & request-reply         \\
		get\_questions                                                    & request-reply         \\
		play                                                              & request-reply         \\
		next                                                              & request-reply         \\
		timesup                                                           & request-reply         \\
		join                                                              & request-reply         \\
		leave                                                             & async                 \\
		rejoin                                                            & async                 \\
		active room notifying the conductor about players joining/leaving & async                
	\end{tabular}
\end{table}


\subsection{Guessing While no Question is Active}
A player of a kaboose game can potentiality guess the answer of a question at any time, even when there is no question currently asked.

We decided to ignore these guesses, the player is neither awarded points for these guesses, nor is he punished.
However, the messages received by the activeRoom process still have to be handeled. Not handling them would mean they remain the the message queue and potentially get interpreted as answers to the next question. Consequently, this solution handles incoming guesses as soon as they arrive, reads from it's internal state whether there is currently an active question, and ignores the guess if there is not.

\subsection{Suggested Improvements to the Kaboose API}
The kaboose API could be improved by:
\begin{enumerate}
	\item Possible implementations of the opaque data type \texttt{Cref} are severely limited by the signature of the \texttt{next()} function having \texttt{Cref} as an input.
	\item Many error cases are not specified in the assignment. This makes it hard to determine what should be handled properly, and which cases should lead to a runtime error.
\end{enumerate}


\pagebreak
\section{Assessment}
This section contains the assessment of the presented solution.


\subsection{Scope of Test Cases}
The \texttt{kaboose\_tests.erl} file contains 22 tests, that cover all the Kaboose functionality. Tests are verifying both positive and negative cases, e.g. verifying if no question will be added in case of empty answer list. In the report, only more interesting parts of the code will be described. 
\\
\\
\noindent - It was necessary to test if only Conductor can use  \texttt{next}, \texttt{timesup}. To do that in the test a method that simulates another pid was created:

\begin{minted}{erlang}
fakeConductorNext(Aroom, Pid) ->
Pid ! kaboose:next(Aroom). 
\end{minted}

\noindent Than it was possible to verify if the caller is actual conductor:

\begin{minted}{erlang}
receive 
	Message -> Message
end,
?assertMatch({error, who_are_you}, Message).
\end{minted}

\noindent- Additionally it was also verified if messages about player status are received only be the conductor. Data should not be leaked. 

\begin{minted}{erlang}
kaboose:join(Aroom, "Konrad"),
receive 
Message -> Message
end,
Me = self(),
?assertMatch({Me,{player_joined, "Konrad", _}}, Message).
\end{minted}

\noindent - Another important and tricky part was checking if points are granted with the respect to the time of answers being received by the server:

\begin{minted}{erlang}
kaboose:next(Aroom),
timer:sleep(600),
kaboose:guess(Aroom, Ref, 1),
{ok,[1,_],Dict,_,true} = kaboose:timesup(Aroom),
Points = maps:get("Konrad", Dict),
?assertMatch(500 ,Points).
\end{minted}
Verification of timer working was performed by checking the number of points that were awarded to the user providing a right answer. 

\subsection{Correctness of Solution}
Based on the tests, analyzing the code we assume the solution is likely to be correct.
\\
Additionally, the solutions passed the Online TA test.

\subsection{Summary of Code Quality}
Based on the tests, we do believe that the functionality of the kaboose server matches the functionality specified by the assignment.

Additionally, we think that our code is very well structured by using three different modules to implement the functionality and extracting the non functional code to the \texttt{basic\_server} module. This leads a better maintainability of the code.

One of the major downsides of this solution is the "perfect world" assumption. By not checking the format of input data, it is very easy to produce a runtime error by inputting ill-formatted data. As we do not implement a Supervisor/Worker pattern in this solution, the application can not recover from this state.


\end{document}
